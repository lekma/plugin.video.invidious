# -*- coding: utf-8 -*-


from __future__ import absolute_import, division, unicode_literals


import collections
import requests

from six.moves.urllib.parse import urljoin, urlunsplit, urlsplit

from . import objects
from ..utils import get_setting, notify, log


class InvidiousSession(requests.Session):

    def __init__(self, headers=None):
        super(InvidiousSession, self).__init__()
        if headers:
            self.headers.update(headers)

    def request(self, *args, **kwargs):
        response = super(InvidiousSession, self).request(*args, **kwargs)
        log("request.url: {}".format(response.url))
        try:
            response.raise_for_status()
        except Exception as error:
            try:
                message = response.json().get("error")
            except Exception:
                message = None
            if message:
                return notify(message, time=5000)
            raise error
        else:
            return response.json()


class InvidiousService(object):

    _headers_ = {}

    _requests_ = {
        "top": (objects.ShortVideos, "top", []),
        "popular": (objects.ShortVideos, "popular", []),
        "trending": (objects.Videos, "trending", []),
        "videos": (objects.Videos, "channels/{}/videos", []),
        "channel": (objects.Channel, "channels/{}", None),
        "video": (objects.Video, "videos/{}", None),
        "playlists": (
            objects.ChannelPlaylists, "channels/{}/playlists",
            {"playlists": [], "continuation": None}
        ),
        "playlist": (
            objects.Playlist, "playlists/{}",
            {"videos": [], "title": None, "authorId": None, "playlistId": None}
        )
    }

    _search_ = {
        "video": objects.Videos,
        "channel": objects.Channels,
        "playlist": objects.Playlists
    }

    def __init__(self):
        self.scheme = "https" if get_setting("ssl", bool) else "http"
        self.netloc = get_setting("instance", unicode)
        path = "{}/".format(get_setting("path", unicode).strip("/"))
        self.url = urlunsplit((self.scheme, self.netloc, path, "", ""))
        self.session = InvidiousSession(headers=self._headers_)
        self._channels_ = {}
        self.queries = collections.deque()

    def get(self, url, **kwargs):
        return self.session.get(urljoin(self.url, url), params=kwargs)

    def query(self, url, fields, *args, **kwargs):
        if fields:
            kwargs["fields"] = ",".join(fields)
        return self.get(url.format(*args), **kwargs)

    def execute(self, key, *args, **kwargs):
        cls, url, default = self._requests_[key]
        return cls, self.query(url, cls.fields(), *args, **kwargs) or default

    def simple(self, *args, **kwargs):
        cls, data = self.execute(*args, **kwargs)
        return cls(data)

    # --------------------------------------------------------------------------

    def _get_channel_(self, authorId):
        channel = self.simple("channel", authorId)
        if channel:
            self._channels_[authorId] = channel
            return channel

    def _channel_(self, authorId):
        try:
            return self._channels_[authorId]
        except KeyError:
            return self._get_channel_(authorId)

    # --------------------------------------------------------------------------

    def top(self, **kwargs):
        return self.simple("top", **kwargs)

    def popular(self, **kwargs):
        return self.simple("popular", **kwargs)

    def trending(self, **kwargs):
        cls, data = self.execute("trending", **kwargs)
        return cls(data, category=kwargs.get("type"))

    def channel(self, page=1, limit=60, **kwargs):
        category = None
        authorId = kwargs.pop("authorId")
        cls, data = self.execute("videos", authorId, page=page, **kwargs)
        channel = self._channel_(authorId)
        if channel:
            category = channel.author
            if channel.autoGenerated:
                limit = 0
        return cls(data, limit=limit, page=page, category=category)

    def playlists(self, **kwargs):
        category = None
        authorId = kwargs.pop("authorId")
        cls, data = self.execute("playlists", authorId, **kwargs)
        channel = self._channel_(authorId)
        if channel:
            category = channel.author
            if channel.autoGenerated:
                data["continuation"] = None
        return cls(data["playlists"], continuation=data["continuation"],
                   category=category)

    def playlist(self, page=1, limit=100, **kwargs):
        cls, data = self.execute("playlist", kwargs.pop("playlistId"),
                                 page=page, **kwargs)
        authorId = data["authorId"]
        if authorId:
            channel = self._channel_(authorId)
            if channel and channel.autoGenerated:
                limit = 0
        return objects.BaseVideos(data["videos"], category=data["title"],
                                  limit=limit, page=page)

    def search(self, q, page=1, limit=20, **kwargs):
        cls = self._search_[kwargs["type"]]
        data = self.query("search", cls.fields(), q=q, page=page, **kwargs) or []
        return cls(data, limit=limit, page=page)


    # --------------------------------------------------------------------------

    def video(self, **kwargs):
        video = self.simple("video", kwargs.pop("videoId"), **kwargs)
        if video:
            url, manifest, mime = (video.dashUrl, "mpd", "application/dash+xml")
            if video.liveNow:
                url, manifest, mime = (video.hlsUrl, "hls", None)
            split = urlsplit(url)
            url = urlunsplit((split.scheme or self.scheme,
                              split.netloc or self.netloc,
                              split.path, split.query, split.fragment))
            return (video._item(url), manifest, mime)


service = InvidiousService()

